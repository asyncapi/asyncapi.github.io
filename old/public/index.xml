<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AsyncAPI Initiative</title>
    <link>https://www.asyncapi.com/</link>
    <description>Recent content on AsyncAPI Initiative</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Sep 2019 17:15:09 +0100</lastBuildDate>
    
	<atom:link href="https://www.asyncapi.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AsyncAPI specification 2.0.0</title>
      <link>https://www.asyncapi.com/docs/specifications/2.0.0/</link>
      <pubDate>Mon, 09 Sep 2019 17:15:09 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/specifications/2.0.0/</guid>
      <description>Choose another version: | 2.0.0 | 1.2.0 | 1.1.0 | 1.0.0 |  Disclaimer Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative. Mainly because it&amp;rsquo;s a great work and we want to keep as much compatibility as possible with the OpenAPI Specification.
Version 2.0.0 The key words &amp;ldquo;MUST&amp;rdquo;, &amp;ldquo;MUST NOT&amp;rdquo;, &amp;ldquo;REQUIRED&amp;rdquo;, &amp;ldquo;SHALL&amp;rdquo;, &amp;ldquo;SHALL NOT&amp;rdquo;, &amp;ldquo;SHOULD&amp;rdquo;, &amp;ldquo;SHOULD NOT&amp;rdquo;, &amp;ldquo;RECOMMENDED&amp;rdquo;, &amp;ldquo;MAY&amp;rdquo;, and &amp;ldquo;OPTIONAL&amp;rdquo; in this document are to be interpreted as described in RFC 2119.</description>
    </item>
    
    <item>
      <title>Event-driven architectures</title>
      <link>https://www.asyncapi.com/docs/getting-started/event-driven-architectures/</link>
      <pubDate>Mon, 01 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/event-driven-architectures/</guid>
      <description>All developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. You enter a URL (e.g., google.com) in the address bar of your favorite browser and it sends a request to the server. Following, the server sends the response with the content of the website. The web is the greatest implementation of a REST API.</description>
    </item>
    
    <item>
      <title>Coming from OpenAPI</title>
      <link>https://www.asyncapi.com/docs/getting-started/coming-from-openapi/</link>
      <pubDate>Mon, 01 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/coming-from-openapi/</guid>
      <description>If you&amp;rsquo;re coming from OpenAPI, you must know that AsyncAPI started as an adaptation of the OpenAPI specification. We wanted to have as much compatibility as possible between the two so users could reuse parts in both.
You&amp;rsquo;ll find lots of similarities between OpenAPI and AsyncAPI. Just bear in mind that, in the world of event-driven architectures, you have more than one protocol and therefore some things are different. Check out the following comparison chart, inspired by Darrel Miller&amp;rsquo;s blog post:</description>
    </item>
    
    <item>
      <title>AsyncAPI specification 1.2.0</title>
      <link>https://www.asyncapi.com/docs/specifications/1.2.0/</link>
      <pubDate>Sat, 16 Feb 2019 17:41:57 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/specifications/1.2.0/</guid>
      <description>Choose another version: | 2.0.0 | 1.2.0 | 1.1.0 | 1.0.0 |  Disclaimer Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative. Mainly because it&amp;rsquo;s a great work and we want to keep as much compatibility as possible with the OpenAPI Specification.
Version 1.2.0 The key words &amp;ldquo;MUST&amp;rdquo;, &amp;ldquo;MUST NOT&amp;rdquo;, &amp;ldquo;REQUIRED&amp;rdquo;, &amp;ldquo;SHALL&amp;rdquo;, &amp;ldquo;SHALL NOT&amp;rdquo;, &amp;ldquo;SHOULD&amp;rdquo;, &amp;ldquo;SHOULD NOT&amp;rdquo;, &amp;ldquo;RECOMMENDED&amp;rdquo;, &amp;ldquo;MAY&amp;rdquo;, and &amp;ldquo;OPTIONAL&amp;rdquo; in this document are to be interpreted as described in RFC 2119.</description>
    </item>
    
    <item>
      <title>AsyncAPI documents</title>
      <link>https://www.asyncapi.com/docs/getting-started/asyncapi-documents/</link>
      <pubDate>Mon, 01 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/asyncapi-documents/</guid>
      <description>An AsyncAPI document is a file that defines and annotates the different components of a specific Event-Driven API.
The format of the file must be JSON or YAML, however, only the subset of YAML that matches the JSON capabilities is allowed.
asyncapi: &amp;#39;2.0.0&amp;#39; id: &amp;#39;urn:com.my-application.example&amp;#39; info: title: Example version: 0.1.0 channels: user/signedup: subscribe: message: description: An event describing that a user just signed up. payload: type: object additionalProperties: false properties: fullName: type: string email: type: string format: email age: type: integer minimum: 18 The AsyncAPI document is a machine-readable definition of your event-driven API.</description>
    </item>
    
    <item>
      <title>AsyncAPI specification 1.1.0</title>
      <link>https://www.asyncapi.com/docs/specifications/1.1.0/</link>
      <pubDate>Sat, 16 Feb 2019 17:41:57 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/specifications/1.1.0/</guid>
      <description>Choose another version: | 2.0.0 | 1.2.0 | 1.1.0 | 1.0.0 |  Disclaimer Part of this content has been taken from the great work done by the folks at the Open API Initiative. Mainly because it&amp;rsquo;s a great work and we want to keep as much compatibility as possible with the Open API Specification.
Version 1.1.0 The key words &amp;ldquo;MUST&amp;rdquo;, &amp;ldquo;MUST NOT&amp;rdquo;, &amp;ldquo;REQUIRED&amp;rdquo;, &amp;ldquo;SHALL&amp;rdquo;, &amp;ldquo;SHALL NOT&amp;rdquo;, &amp;ldquo;SHOULD&amp;rdquo;, &amp;ldquo;SHOULD NOT&amp;rdquo;, &amp;ldquo;RECOMMENDED&amp;rdquo;, &amp;ldquo;MAY&amp;rdquo;, and &amp;ldquo;OPTIONAL&amp;rdquo; in this document are to be interpreted as described in RFC 2119.</description>
    </item>
    
    <item>
      <title>AsyncAPI specification 1.0.0</title>
      <link>https://www.asyncapi.com/docs/specifications/1.0.0/</link>
      <pubDate>Sat, 16 Feb 2019 17:41:57 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/specifications/1.0.0/</guid>
      <description>Choose another version: | 2.0.0 | 1.2.0 | 1.1.0 | 1.0.0 |  Disclaimer Part of this content has been taken from the great work done by the folks at the Open API Initiative. Mainly because it&amp;rsquo;s a great work and we want to keep as much compatibility as possible with the Open API Specification.
Version 1.0.0 The key words &amp;ldquo;MUST&amp;rdquo;, &amp;ldquo;MUST NOT&amp;rdquo;, &amp;ldquo;REQUIRED&amp;rdquo;, &amp;ldquo;SHALL&amp;rdquo;, &amp;ldquo;SHALL NOT&amp;rdquo;, &amp;ldquo;SHOULD&amp;rdquo;, &amp;ldquo;SHOULD NOT&amp;rdquo;, &amp;ldquo;RECOMMENDED&amp;rdquo;, &amp;ldquo;MAY&amp;rdquo;, and &amp;ldquo;OPTIONAL&amp;rdquo; in this document are to be interpreted as described in RFC 2119.</description>
    </item>
    
    <item>
      <title>Nunjucks templating explained on the basis of AsyncAPI specification</title>
      <link>https://www.asyncapi.com/blog/using-nunjucks-with-asyncapi/</link>
      <pubDate>Tue, 03 Mar 2020 08:00:00 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/using-nunjucks-with-asyncapi/</guid>
      <description>Specifications exist for a reason. Among other things, they help to bring quality, consistency, and standardize a given area. They are a great use case for templating engines. You can prepare a template that generates something from any document that follows a particular specification. You can generate whatever you want, docs, code, and diagrams. The sky is the limit.
Templating is a vast topic that is impossible to cover in a single post.</description>
    </item>
    
    <item>
      <title>Hello world</title>
      <link>https://www.asyncapi.com/docs/getting-started/hello-world/</link>
      <pubDate>Mon, 01 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/hello-world/</guid>
      <description>Let&amp;rsquo;s define an application that&amp;rsquo;s capable of receiving a &amp;ldquo;hello {name}&amp;rdquo; message.
asyncapi: 2.0.0 info: title: Hello world application version: &#39;0.1.0&#39; channels: hello: publish: message: payload: type: string pattern: &#39;^hello .+$&#39;  Let&amp;rsquo;s get into the details of the sample specification:
asyncapi: 2.0.0 info: title: Hello world application version: &amp;#39;0.1.0&amp;#39; channels: hello: publish: message: payload: type: string pattern: &amp;#39;^hello .&amp;#43;$&amp;#39; The first line of the specification starts with the document type, asyncapi, and the version (2.</description>
    </item>
    
    <item>
      <title>Servers</title>
      <link>https://www.asyncapi.com/docs/getting-started/servers/</link>
      <pubDate>Wed, 03 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/servers/</guid>
      <description>In the previous lesson, you learned how to create the definition of a simple Hello World application, so let&amp;rsquo;s take it from there.
In this article, you learn how to add servers to your AsyncAPI document. Adding and defining servers is useful because it specifies where and how to connect. The connection facilitates where to send and receive messages.
asyncapi: 2.0.0 info: title: Hello world application version: &amp;#39;0.1.0&amp;#39; servers: production: url: broker.</description>
    </item>
    
    <item>
      <title>Adding security</title>
      <link>https://www.asyncapi.com/docs/getting-started/security/</link>
      <pubDate>Tue, 16 Apr 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/getting-started/security/</guid>
      <description>In production environments, your API may have to access a message broker that&amp;rsquo;s protected by some auth mechanisms. Examples of these are:
 User &amp;amp; password Certificates API keys OAuth 2  If you&amp;rsquo;re using AsyncAPI to define an API that connects to a message broker, you&amp;rsquo;ll most probably make use of user/password or certificates. Traditionally, message brokers are infrastructure pieces that serve an internal purpose and they&amp;rsquo;re not exposed to the public.</description>
    </item>
    
    <item>
      <title>AsyncAPI 2.0.0 important dates</title>
      <link>https://www.asyncapi.com/blog/v2-important-dates/</link>
      <pubDate>Wed, 12 Jun 2019 10:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/v2-important-dates/</guid>
      <description>Hey folks! After some time thinking about it, I&amp;rsquo;ve decided it&amp;rsquo;s time to define some important dates for AsyncAPI 2.0.0. So here we go!
End of review period (July 1, 2019) After some time, many people have reviewed the specification and they&amp;rsquo;ve identified some issues that need to be addressed before we launch the version 2.0.0. Actually, this process will never finish but we have to decide on a date to stop reviewing and move forward.</description>
    </item>
    
    <item>
      <title>AsyncAPI and CloudEvents</title>
      <link>https://www.asyncapi.com/blog/asyncapi-cloud-events/</link>
      <pubDate>Sat, 11 May 2019 16:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/asyncapi-cloud-events/</guid>
      <description>I&amp;rsquo;ve been receiving the same question for a long time now: Should I use CloudEvents or AsyncAPI? — And my response has always been the same: it depends!
There is the belief by many people that AsyncAPI and CloudEvents are competing for the same thing. This can&amp;rsquo;t be less true, and I&amp;rsquo;d like to explain you why. Read on!
What is CloudEvents? From cloudevents.io:
 Enter CloudEvents, a specification for describing event data in a common way.</description>
    </item>
    
    <item>
      <title>Replicating the Success of REST in Event-Driven Architecture</title>
      <link>https://www.asyncapi.com/blog/replicating-success-rest-event-driven-architecture/</link>
      <pubDate>Thu, 04 Apr 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/replicating-success-rest-event-driven-architecture/</guid>
      <description>This post is a collaboration between Fran Méndez of AsyncAPI and Solace’s Jonathan Schabowsky. It was originally published at Solace’s blog.
Jonathan explained in his last blog post how the loose coupling of applications associated with event-driven architecture and publish/subscribe messaging is both a strength and a weakness. As part of that, he touched on the fact that request/reply interactions using RESTful APIs are still the dominant application integration paradigm, even in hybrid cloud, machine learning and IoT use cases that benefit from event-driven interactions.</description>
    </item>
    
    <item>
      <title>An API Strategist Explores Event-Driven APIs</title>
      <link>https://www.asyncapi.com/blog/an-api-strategist-explores-event-driven-apis/</link>
      <pubDate>Tue, 14 May 2019 16:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/an-api-strategist-explores-event-driven-apis/</guid>
      <description>An API Strategist Explores Event-Driven APIs If you’re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you.
I virtually sat down with these experts:
 Fran Mendez, Founder of AsyncAPI
 Jonathan Schabowsky, Chief Architect, Solace
 David McKenna, SVP, Research &amp;amp; Development, Axway
 Eric Horesnyi, General Manager, APIs &amp;amp; Integration, Axway (CEO of Streamdata.</description>
    </item>
    
    <item>
      <title>Status update (week 17, 2019)</title>
      <link>https://www.asyncapi.com/blog/status-update-week-17-2019/</link>
      <pubDate>Thu, 25 Apr 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/status-update-week-17-2019/</guid>
      <description>Alas güenas tardis! This week we&amp;rsquo;ve made significant progress on the documentation and the parser. The goal is to make AsyncAPI 2.0.0 easy and quick to learn at the same time we provide you the necessary tools to start playing with it. Check out the progress so far:
The parser  Compile for all platforms: One of the hardest things to solve, before we continue moving forward, was the compilation process.</description>
    </item>
    
    <item>
      <title>Getting started with event-driven architectures</title>
      <link>https://www.asyncapi.com/blog/getting-started-with-event-driven-architectures/</link>
      <pubDate>Fri, 19 Apr 2019 16:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/getting-started-with-event-driven-architectures/</guid>
      <description>All developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. You enter a URL (e.g., google.com) in the address bar of your favorite browser and it sends a request to the server. Following, the server sends the response with the content of the website. The web is the greatest implementation of a REST API.</description>
    </item>
    
    <item>
      <title>Status update (week 15, 2019)</title>
      <link>https://www.asyncapi.com/blog/status-update-week-15-2019/</link>
      <pubDate>Thu, 11 Apr 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/status-update-week-15-2019/</guid>
      <description>Kaixo lagunak! This week we continued working on the parser as it’s a top priority for us. We made significant progress and plan to release a simple but functional version soon.
Building the parser  We’ve added support for AsyncAPI 1.x/OpenAPI schemas. This is the first step before we dive into Avro and Protobuf support. Updated the Node.js to automatically test itself on Linux, Mac, and Windows. We’re still struggling to debug some failures on Windows so we encourage people who work on this operating system to join and help us test.</description>
    </item>
    
    <item>
      <title>Status update (week 14, 2019)</title>
      <link>https://www.asyncapi.com/blog/status-update-week-14-2019/</link>
      <pubDate>Thu, 04 Apr 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/status-update-week-14-2019/</guid>
      <description>Hallo meine Freunde! This week we’ve done great progress on tooling and documentation. It will be our main focus for the next month. In the meantime, check out what we did last week. Read on!
Improvements on documentation  Check out version 2.0.0-rc1 of the specification in our website: https://www.asyncapi.com/docs/specifications/2.0.0-rc1/. Added a “Hello world” article to our getting started guide: https://github.com/asyncapi/asyncapi.github.io/pull/3. Added a “Servers” article to our getting started guide, explaining how the “servers” section of AsyncAPI works: https://github.</description>
    </item>
    
    <item>
      <title>Organizing your AsyncAPI documents</title>
      <link>https://www.asyncapi.com/blog/organizing-asyncapi-documents/</link>
      <pubDate>Fri, 01 Mar 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/blog/organizing-asyncapi-documents/</guid>
      <description>A recurring question that I get very often is: “how do I organize my AsyncAPI documents?”. Also, the related one: “I have two services, a publisher and a consumer, should I define both in the same AsyncAPI document?”.
Let’s break down some best practices and tips to avoid ending up in a hell of unmanageable documents.
Organizing Microservices  I’m using the term microservices here because it’s the most common type of distributed architecture that you can find nowadays.</description>
    </item>
    
    <item>
      <title>Streetlights</title>
      <link>https://www.asyncapi.com/docs/tutorials/streetlights/</link>
      <pubDate>Sat, 16 Feb 2019 17:41:57 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/tutorials/streetlights/</guid>
      <description>&lt;p&gt;In this tutorial, you get started with actual code and a (could-be) real-world use case.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.asyncapi.com/about/</link>
      <pubDate>Sat, 16 Feb 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/about/</guid>
      <description>Maintainers AsyncAPI is actively maintained by:
 Fran Méndez - Project Director. Łukasz Górnicki - Maintainer and Dev Community Keeper.  So far, we have had many contributors and we are thankful for their time and help.
Contributors We do our best to recognize every contribution to the project. We do it individually in every repository from AsyncAPI GitHub organization. There should always be a Contributors section in the readme, like this one.</description>
    </item>
    
    <item>
      <title>Tooling</title>
      <link>https://www.asyncapi.com/docs/tooling/</link>
      <pubDate>Sat, 16 Feb 2019 13:56:52 +0100</pubDate>
      
      <guid>https://www.asyncapi.com/docs/tooling/</guid>
      <description>&lt;p&gt;This page contains a list of AsyncAPI tooling. Would you like to add your tool to this list? &lt;a href=&#34;https://github.com/asyncapi/asyncapi/issues/new&#34; target=&#34;_blank&#34;&gt;Let us know!&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.asyncapi.com/subscribe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.asyncapi.com/subscribe/</guid>
      <description>Your browser doesn&#39;t support iframes </description>
    </item>
    
  </channel>
</rss>